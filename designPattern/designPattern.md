# 设计模式
## 六大原则
### 单一职责原则 
定义：就一个类而言，应该仅有一个引起它变化的原因。从这句定义我们很难理解它的含义，这通俗地讲就是我们不要让一个类承担过多的职责。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。单一职责的划分界限不是很清晰，很多时候需要靠个人经验来界定，因此它是一个饱受争议却又极其重要的原则。
### 开放封闭原则 
定义：类、模块、函数等应该是可以拓展的，但是不可修改。开放封闭有两个含义：一个是对于拓展是开放的，另一个是对于修改是封闭的。
### 里氏替换原则 
定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象。里氏替换原则告诉我们，在软件中将一个基类对象替换成其子类对象，程序将不会产生任何错误和异常；反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。里氏替换原则是实现开放封闭原则的重要方式之一。由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。在使用里氏替换原则时需要注意以下几个问题。子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏替换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义。如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。我们在运用里氏替换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法。运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码；增加新的功能可以通过增加一个新的子类来实现。里氏替换原则是开放封闭原则的具体实现手段之一。在Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏替换原则。这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限性的。
### 依赖倒置原则 
定义：高层模块不应该依赖低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。在Java中，抽象指接口或者抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或者继承抽象类而产生的就是细节，也就是可以加上一个关键字new产生的对象。高层模块就是调用端，低层模块就是具体实现类。依赖倒置原则在Java中的表现就是，模块间的依赖通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口或者抽象类产生的。如果类与类直接依赖细节，那么就会直接耦合。如此一来当修改时，就会同时修改依赖者代码，这样限制了可扩展性。
### 迪米特原则 
定义：一个软件实体应当尽可能少地与其他实体发生相互作用。这也被称为最少知识原则。如果一个系统符合迪米特原则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块。迪米特原则要求我们在设计系统时，应该尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用。如果其中的一个对象需要调用另一个对象的某一个方法，则可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。在将迪米特原则运用到系统设计中时，要注意下面几点：中的类一旦被修改，则不会对关联的类造成太大波及。
* 在类的划分上，应当尽量创建松耦合的类。类之间的耦合度越低，就越有利于复用。一个处在松耦合
* 在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限。
* 在对其他类的引用上，一个对象对其他对象的引用应当降到最低。

### 接口隔离原则 
定义：一个类对另一个类的依赖应该建立在最小的接口上。建立单一接口，不要建立庞大臃肿的接口；尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图建立一个很庞大的接口供所有依赖它的类调用。采用接口隔离原则对接口进行约束时，要注意以下几点：接口数量过多，使设计复杂化。所以，一定要适度。地为一个模块提供定制服务，才能建立最小的依赖关系。
* 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计的灵活性；但是如果过小，则会造成接口数量过多，使设计复杂化。所以，一定要适度。
* 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。
*  提高内聚，减少对外交互。接口方法尽量少用public修饰。接口是对外的承诺，承诺越少对系统的开发越有利，变更风险也会越少。

## 创建型设计模式
* 单例模式
* 工厂方法模式
* 抽象工厂模式，通过反射不用写case
* 建造者模式
* 原型模式

## 结构型设计模式
* 适配器模式
*  装饰模式，优点是动态、透明的方式给单个对象添加职。实现是继承和注入，基类改变也会影响，装饰层数不能过多，否则会影响效率。
* 代理模式，静态代理，在代码运行前就已经存在了代理类的class编译文件；而动态代理则是在代码运行时通过反射来动态地生成代理类的对象，并确定到底来代理谁。也就是我们在编码阶段无须知道代理谁，代理谁将会在代码运行时决定。Java 提供了动态的代理接口 InvocationHandler，实现该接口需要重写invoke（）方法。代理模式的优点主要有以下几点：
	* 真实主题类就是实现实际的业务逻辑，不用关心其他非本职的工作。
	* 真实主题类随时都会发生变化；但是因为它实现了公共的接口，所以代理类可以不做任何修改就能够使用
* 外观模式，对用户隐藏了子系统的具体实现，减少用户对子系统的耦合。这样即使具体的子系统发生了变化，用户也不会感知到。
*  桥接模式
* 组合模式
* 享元模式，使用共享对象有效地支持大量细粒度的对象

## 行为型设计模式
* 策略模式，条件判断里面又有条件判断，策略模式将相关的条件分支移入它们各自的 Strategy 类中，以代替这些条件语句
* 模板方法模式
* 观察者模式
* 迭代器模式
* 责任链模式
* 命令模式
* 备忘录模式
* 状态模式
* 访问者模式
* 中介者模式
*  解释器模式

## 规格模式
## 对象池模式
## 雇工模式
## 黑板模式
## 空对象模式

