# 启动优化
## 前言
启动是指用户从点击 icon 到看到页面首帧的整个过程，启动优化的目标就是减少这一过程的耗时。
启动过程比较复杂，在进程与线程维度，它涉及到多次跨进程的通信与多个线程之间的切换；在耗时成因维度，它包括 CPU、CPU 调度、IO、锁等待等多类耗时。虽然启动过程比较复杂，但是我们最终可以把它抽象成主线程的一个线性过程。因此对于启动性能的优化，就是去缩短主线程的这个线性过程。

## 相关指标


### 启动的3个阶段
* T1 预览窗口显示。系统在拉起进程之前，会先根据App Theme 属性创建预览窗口。当然如果我们禁用预览窗口或者将预览窗口指定为透明，用户在这段时间依然看到的是桌面。
* T2 Activity显示
* T3 Window焦点获取

### 冷启动耗时
## 优化措施
### UI
### 主线程优化
#### Application attachBaseContext
#### ContentProvider
我们可以通过JetPack提供的Startup将多个初始化的ContentProvider聚合成一个来进行优化。
#### Applicaiotn onCreate
依赖有向无环图
#### Actvity

### 序列化优化
#### gson优化
* 统一 Gson 对象：Gson 会对解析过的 Class 进行 TypeAdapter 的缓存，但是这个缓存是 Gson 对象级别的，不同 Gson 对象之间不会进行复用，通过统一 Gson 对象可以实现 TypeAdapter 的复用；
* 预创建 TypeAdapter：对于有足够的并发空间场景，我们在异步线程提前创建相关 Class 的 TypeAdapter，后续则可以直接使用预创建的 TypeAdapter 进行数据解析；
* 使用其他协议：对于本地数据的序列化与反序列化我们尝试使用了二进制顺序化的存储方式，将反序化耗时减少了 95%。

### Load so优化
System.loadLibrary()方法用于加载当前apk中的so库，这个方法对Runtime对象加了锁，相当于一个类锁。

基础SDK在设计上通常会将load so的操作写到类的静态代码块中，确保在SDK初始化代码执行之前就准备好了so库。如果这个基础SDK恰巧是网络库这类基础库，会被很多其他SDK调用，就会出现多个线程同时竞争这个锁的情况。那么在最坏的情况下，此时IO资源紧张，读so文件变慢，并且主线程是锁等待队列中最后一个，那么启动耗时将远超预期。

这些so加载的代码全部挪到相关类的静态代码块中，然后再去触发这些类的加载即可，利用类加载的机制确保这些so的加载操作不会重复执行，同时这些类加载的顺序也要按照这些so使用的顺序来编排。
###  WebView 初始化
WebSetting.getDefaultUserAgent()延时加载

### GC抑制
触发 GC 后可能会抢占我们的 cpu 资源甚至导致我们的线程被挂起，如果启动过程中存在大量的 GC，那么我们的启动速度将会受到比较大的影响。

解决这个问题的一个方法就是减少我们启动阶段代码的执行，减少内存资源的申请与占用，这个方案需要我们去改造我们的代码实现，是解决 gc 影响启动速度的最根本办法。

## 防劣化
主线程消息Looper调度
根据message.what和message.getTarget()判断再消息队列中是否存在目标消息

## 分析工具
systrace


## 优化

- 闪屏优化
    - 将启动页主题背景设置成闪屏页图片
    - 主页面布局优化


- 业务梳理
    - 哪些是一定需要的、哪些可以砍掉、哪些可以懒加载。
- 业务优化
- 线程优化
    - TraceView
    - systrace 可以看到锁等待的事件
    - 阿里的alpha构成的有向无环图

- gc优化

- 系统调用优化，减少binder

- MultiDex优化

    - App集成一堆库之后，方法数一般都是超过65536的，解决办法就是：一个dex装不下，用多个dex来装，gradle增加一行配置即可，multiDexEnabled true，这样解决了编译问题，在5.0以上手机运行正常，但是5.0以下手机运行直接crash，报错 Class NotFound xxx。Android 5.0以下，ClassLoader加载类的时候只会从class.dex（主dex）里加载，ClassLoader不认识其它的class2.dex、class3.dex、...，当访问到不在主dex中的类的时候，就会报错:Class NotFound xxx，因此谷歌给出兼容方案，MultiDex。


- IO优化
   
- 数据重排
    - 类重排--ReDex，利用 Linux 文件系统的 pagecache 机制，用最少的磁盘 IO 次数，读取尽可能多的启动阶段需要的文件，减少 IO 开销，从而达到提升启动性能的目的。
    - 资源重排

- 类预加载优化,在Application中提前异步加载初始化耗时较长的类。

    - 如何找到耗时较长的类？替换系统的ClassLoader，打印类加载的时间，按需选取需要异步加载的类。
    - 注意：
         - Class.forName()只加载类本身及其静态变量的引用类。
         - new 类实例 可以额外加载类成员变量的引用类。

